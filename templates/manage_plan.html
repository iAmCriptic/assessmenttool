<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lageplan verwalten</title>
    <link id="faviconLink" href="{{ url_for('general.static_files', filename='img/logo_V2.png') }}" rel="icon" type="image/vnd.microsoft.icon">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.2.0/uicons-regular-rounded/css/uicons-regular-rounded.css'>
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.2.0/uicons-solid-rounded/css/uicons-solid-rounded.css'>
    <style>
        /* Grundlegende Body-Stile für Light- und Dark-Mode */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        /* Die Dark Mode Hintergrundfarben werden nun vollständig über JavaScript gesetzt,
           basierend auf den Admin-Einstellungen. Die CSS-Klasse 'dark' wird nur für
           andere Dark Mode-Stile (Textfarben, Box-Schatten etc.) verwendet. */
        body.dark {
            color: #e2e8f0;
            background-color: #000000; /* Standardmäßig schwarz für Dark Mode */
        }
        /* Dark Mode für Hauptcontainer */
        .main-container {
            background-color: #ffffff; /* Weiß für Light Mode */
            color: #1f2937; /* Dunkler Text für Light Mode */
            transition: background-color 0.3s ease, color 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* Leichter Schatten im Light Mode */
        }
        .dark .main-container {
            background-color: #000000; /* Schwarz für Dark Mode */
            color: #e2e8f0; /* Heller Text für Dark Mode */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.3); /* Stärkerer Schatten im Dark Mode */
        }
        /* Allgemeine Textfarben */
        body:not(.dark), /* Im Light Mode */
        body:not(.dark) .text-gray-800,
        body:not(.dark) .text-gray-600,
        body:not(.dark) .text-gray-900,
        body:not(.dark) .text-gray-700 { /* Zusätzliche Spezifikation für Labels */
            color: #1f2937; /* Schwarz für Light Mode Text */
        }
        body.dark, .dark .text-gray-800, .dark .text-gray-600, .dark .text-gray-900, .dark .text-gray-700 {
            color: #e2e8f0; /* Heller Text für Dark Mode */
        }
        .dark .border-gray-200 {
            border-color: #4a5568;
        }
        .dark .shadow-md {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
        }
        .dark .hover\:bg-gray-100:hover {
            background-color: #2d3748;
        }
        .dark .bg-blue-600 {
            background-color: #4299e1;
        }
        .dark .hover\:bg-blue-700:hover {
            background-color: #63b3ed;
        }
        .dark .bg-red-600 {
            background-color: #e53e3e;
        }
        .dark .hover\:bg-red-700:hover {
            color: #fc8181;
        }
        .dark .bg-green-500 {
            background-color: #48bb78;
        }
        .dark .bg-yellow-500 {
            background-color: #f6e05e;
        }
        .dark .bg-purple-600 {
            background-color: #9f7aea; /* Dunkleres Lila für Dark Mode */
        }
        .dark .hover\:bg-purple-700:hover {
            background-color: #b794f4; /* Hellere Lila auf Hover */
        }

        /* Zusätzliche Stile für Icons in Buttons */
        .fi {
            vertical-align: middle; /* Vertikale Ausrichtung */
            color: currentColor; /* Sicherstellen, dass die Farbe vom Elternelement geerbt wird */
            /* Explizite Font-Family, um sicherzustellen, dass die Icon-Schriftart verwendet wird */
            font-family: 'uicons-regular-rounded', 'uicons-solid-rounded', sans-serif !important;
            font-style: normal; /* Sicherstellen, dass der Stil nicht kursiv ist */
            font-weight: normal; /* Sicherstellen, dass der Stil nicht fett ist */
        }
        /* Spezifische Größe für Flagsome Icons, um sie konsistent zu halten */
        .fi::before {
            font-size: 24px; /* Standardgröße für Icons */
        }
        /* Sicherstellen, dass das Icon im Dark Mode Toggle sichtbar ist */
        #darkModeToggle .fi::before, #backButton .fi::before {
            color: inherit; /* Vererbt die Farbe vom Button */
        }

        /* Spezifische Stile für den Dark Mode Toggle und Zurück Button */
        #darkModeToggle, #backButton {
            background-color: #000000 !important; /* Erzwingt schwarzen Hintergrund */
            color: #ffffff !important; /* Erzwingt weißes Icon */
            width: 48px; /* Feste Breite */
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease, color 0.3s ease;
            border-radius: 0.5rem; /* rounded-lg */
        }

        body.dark #darkModeToggle, body.dark #backButton {
            background-color: #ffffff !important; /* Erzwingt weißen Hintergrund */
            color: #000000 !important; /* Erzwingt schwarzes Icon */
        }

        /* Inline Message Styles */
        .inline-message {
            padding: 0.75rem 1.25rem;
            margin-bottom: 1rem;
            border: 1px solid transparent;
            border-radius: 0.375rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            min-width: 300px;
            text-align: center;
        }
        .inline-message.show {
            opacity: 1;
        }
        .inline-message.success {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .inline-message.error {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        .inline-message.info {
            background-color: #d1ecf1;
            border-color: #bee5eb;
            color: #0c5460;
        }
        .dark .inline-message.success {
            background-color: #2f855a;
            border-color: #38a169;
            color: #e6fffa;
        }
        .dark .inline-message.error {
            background-color: #c53030;
            border-color: #e53e3e;
            color: #fed7d7;
        }
        .dark .inline-message.info {
            background-color: #2b6cb0;
            border-color: #4299e1;
            color: #ebf8ff;
        }

        /* Canvas specific styles */
        #floorPlanCanvas {
            border: 1px solid #ccc;
            cursor: grab;
            background-color: #f0f0f0; /* Default background if no image */
            touch-action: none; /* Prevent browser touch actions for custom panning/zoom */
        }
        .dark #floorPlanCanvas {
            border-color: #666;
            background-color: #333;
        }
        #floorPlanCanvas.scale-mode {
            cursor: crosshair; /* Crosshair cursor in scale mode */
        }


        /* Toolbox item styles */
        .toolbox-item {
            cursor: grab;
            border: 1px solid #ccc;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border-radius: 0.375rem;
            background-color: #fff;
            color: #1f2937;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            font-weight: 600; /* font-semibold */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .toolbox-item:hover {
            background-color: #f0f0f0;
            border-color: #aaa;
        }
        .dark .toolbox-item {
            background-color: #1a202c;
            color: #e2e8f0;
            border-color: #4a5568;
        }
        .dark .toolbox-item:hover {
            background-color: #2d3748;
            border-color: #666;
        }
        .toolbox-item i.fi {
            font-size: 2rem; /* Adjusted for larger icons in toolbox */
            margin-bottom: 0.25rem;
        }
        .toolbox-item.trash-can { width: 60px; height: 60px; }
        .toolbox-item.power-outlet { width: 60px; height: 60px; }

        /* Color picker container */
        .color-picker-container {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #aaa;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .color-dot.selected {
            border: 2px solid #3b82f6; /* ring-blue-500 */
            transform: scale(1.1);
        }

        /* Specific styles for active color dots (Tailwind colors) */
        .color-dot.yellow-lid { background-color: #facc15; } /* yellow-400 */
        .color-dot.blue-lid { background-color: #3b82f6; } /* blue-500 */
        .color-dot.black-lid { background-color: #1f2937; } /* gray-800 */

        /* Legend item styling */
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .legend-color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #aaa;
            margin-right: 0.5rem;
            border-radius: 0.25rem;
        }

        /* Dark mode for inputs and select */
        input[type="number"],
        input[type="text"],
        select {
            background-color: #ffffff; /* Weiß im Light Mode */
            color: #1f2937; /* Schwarz im Light Mode */
            border-color: #d1d5db; /* border-gray-300 */
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .dark input[type="number"],
        .dark input[type="text"],
        .dark select {
            background-color: #1c1c1c;
            color: #ffffff;
            border-color: #555555;
        }

        input::placeholder {
            color: #6b7280; /* placeholder-gray-500 */
        }
        .dark input::placeholder {
            color: #aaaaaa;
        }

        input[type="file"]::-webkit-file-upload-button {
            background-color: #eff6ff; /* blue-50 */
            color: #1d4ed8; /* blue-700 */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark input[type="file"]::-webkit-file-upload-button {
            background-color: #1c1c1c; /* Adjusted for dark mode */
            color: #63b3ed;
        }

        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #dbeafe; /* blue-100 */
        }
        .dark input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #2d3748; /* Adjusted for dark mode */
        }

        /* Styling for the container elements (divs with content) */
        .content-card {
            background-color: #ffffff; /* White in Light Mode */
            transition: background-color 0.3s ease;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); /* Leichter Schatten im Light Mode */
        }
        .dark .content-card {
            background-color: #1a202c; /* Darker in Dark Mode */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.3); /* Stärkerer Schatten im Dark Mode */
        }

        /* Collapsible section styles */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem 0;
            margin-bottom: 0.5rem;
        }
        .collapsible-header i {
            transition: transform 0.3s ease;
        }
        .collapsible-header.collapsed i {
            transform: rotate(-90deg);
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            max-height: 1000px; /* Large enough to show content, will be adjusted by JS */
        }
        .collapsible-content.collapsed {
            max-height: 0;
        }
    </style>
</head>
<body class="{{ 'dark' if dark_mode_enabled else '' }} flex flex-col items-center p-4 min-h-screen bg-gray-100 dark:bg-gray-900">
    <div id="inline-message-container" class="inline-message"></div>

    <div class="main-container w-full max-w-6xl rounded-lg shadow-md p-6 relative">
        {# Header with back, logo, and dark mode toggle #}
        <div class="absolute top-0 left-0 p-4">
            <button id="backButton" class="w-12 h-12 transition duration-300 rounded-lg">
                <i class="fi fi-rr-angle-left"></i>
            </button>
        </div>
        <div class="absolute top-0 right-0 p-4">
            <button id="darkModeToggle" class="w-12 h-12 transition duration-300 rounded-lg">
                <i class="fi fi-rr-eclipse-alt"></i>
            </button>
        </div>
        <img id="mainLogo" src="{{ url_for('general.static_files', filename='img/logo_V2.png') }}" alt="Logo" class="max-h-16 mx-auto mb-4">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-800 dark:text-gray-200">Lageplan verwalten</h1>

        {# Main content grid #}
        <div class="flex flex-col lg:flex-row gap-6">
            {# Left Sidebar: File Upload, Toolbox, Scale Definition #}
            <div class="w-full lg:w-1/4 flex flex-col gap-6">
                {# Plan Upload #}
                <div class="p-4 content-card rounded-lg shadow-sm">
                    <div class="collapsible-header" data-target="planUploadContent">
                        <h2 class="text-xl font-semibold text-gray-800 dark:text-gray-200">Lageplan hochladen</h2>
                        <i class="fi fi-rr-angle-down text-xl text-gray-800 dark:text-gray-200"></i>
                    </div>
                    <div id="planUploadContent" class="collapsible-content">
                        <input type="file" id="floorPlanUpload" accept="image/*" class="w-full text-sm text-gray-900 dark:text-gray-100
                                                                                            file:mr-4 file:py-2 file:px-4
                                                                                            file:rounded-full file:border-0
                                                                                            file:text-sm file:font-semibold
                                                                                            file:bg-blue-50 file:text-blue-700
                                                                                            hover:file:bg-blue-100">
                        <button id="uploadPlanButton" class="mt-3 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">
                            Plan hochladen & aktivieren
                        </button>
                        <p id="currentPlanInfo" class="mt-2 text-sm text-gray-600 dark:text-gray-300"></p>
                    </div>
                </div>

                {# Scale Definition #}
                <div class="p-4 content-card rounded-lg shadow-sm">
                    <div class="collapsible-header" data-target="scaleDefinitionContent">
                        <h2 class="text-xl font-semibold text-gray-800 dark:text-gray-200">Maßstab definieren</h2>
                        <i class="fi fi-rr-angle-down text-xl text-gray-800 dark:text-gray-200"></i>
                    </div>
                    <div id="scaleDefinitionContent" class="collapsible-content">
                        <p class="text-sm text-gray-600 dark:text-gray-300 mb-2">Aktivieren Sie den Modus, klicken Sie auf den Plan, um zwei Punkte zu setzen, und geben Sie dann die reale Distanz ein.</p>
                        <button id="toggleScaleModeButton" class="mt-2 w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg">
                            Maßstab Modus aktivieren
                        </button>
                        <div class="flex items-center mb-2 mt-3">
                            <span class="font-semibold mr-2 text-gray-800 dark:text-gray-200">Punkt 1:</span>
                            <span id="scalePoint1Display" class="text-gray-600 dark:text-gray-300">-</span>
                        </div>
                        <div class="flex items-center mb-2">
                            <span class="font-semibold mr-2 text-gray-800 dark:text-gray-200">Punkt 2:</span>
                            <span id="scalePoint2Display" class="text-gray-600 dark:text-gray-300">-</span>
                        </div>
                        <input type="number" id="scaleDistanceInput" placeholder="Distanz in Metern (z.B. 10)" class="w-full p-2 border border-gray-300 rounded-md bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200" step="0.1">
                        <button id="setScaleButton" class="mt-3 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg" disabled>
                            Maßstab speichern
                        </button>
                        <p id="pixelsPerMeterDisplay" class="mt-2 text-sm text-gray-600 dark:text-gray-300"></p>
                    </div>
                </div>

                {# Toolbox #}
                <div class="p-4 content-card rounded-lg shadow-sm">
                    <div class="collapsible-header" data-target="toolboxContent">
                        <h2 class="text-xl font-semibold text-gray-800 dark:text-gray-200">Toolbox</h2>
                        <i class="fi fi-rr-angle-down text-xl text-gray-800 dark:text-gray-200"></i>
                    </div>
                    <div id="toolboxContent" class="collapsible-content">
                        <div class="grid grid-cols-2 gap-4">
                            <div class="toolbox-item" draggable="true" data-object-type="stand">
                                <i class="fi fi-sr-building"></i>
                                <span>Stand</span>
                            </div>
                            <div class="toolbox-item" draggable="true" data-object-type="trash_can">
                                <i class="fi fi-rr-trash"></i>
                                <span>Mülleimer</span>
                            </div>
                            <div class="toolbox-item" draggable="true" data-object-type="power_outlet">
                                <i class="fi fi-rr-plug"></i>
                                <span>Steckdose</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {# Center Area: Canvas and Right Sidebar content now inside #}
            <div class="w-full lg:w-3/4 flex flex-col items-center relative overflow-hidden bg-gray-200 dark:bg-gray-700 rounded-lg shadow-md">
                <div class="flex-grow w-full h-full flex items-center justify-center">
                    <canvas id="floorPlanCanvas" class="max-w-full max-h-full block"></canvas>
                </div>
                <div class="absolute bottom-4 left-1/2 -translate-x-1/2 flex gap-2">
                    <button id="zoomInButton" class="p-2 bg-blue-500 text-white rounded-full"><i class="fi fi-rr-plus-small"></i></button>
                    <button id="zoomOutButton" class="p-2 bg-blue-500 text-white rounded-full"><i class="fi fi-rr-minus-small"></i></button>
                </div>

                <!-- Moved panels, positioned absolutely -->
                <div class="absolute top-4 right-4 flex flex-col gap-4 z-10 w-80 max-h-[calc(100%-2rem)] overflow-y-auto">
                    {# Object Properties Editor #}
                    <div id="objectPropertiesPanel" class="p-4 content-card rounded-lg shadow-sm hidden">
                        <div class="collapsible-header" data-target="objectPropertiesContent">
                            <h2 class="text-xl font-semibold text-gray-800 dark:text-gray-200">Objekt-Eigenschaften</h2>
                            <i class="fi fi-rr-angle-down text-xl text-gray-800 dark:text-gray-200"></i>
                        </div>
                        <div id="objectPropertiesContent" class="collapsible-content">
                            <input type="hidden" id="objectId">
                            <input type="hidden" id="objectType">

                            <div class="mb-3">
                                <label for="objectName" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Name / Stand:</label>
                                <select id="objectStandId" class="mt-1 block w-full p-2 border border-gray-300 rounded-md bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200">
                                    <option value="">Wählen Sie einen Stand...</option>
                                </select>
                                <input type="text" id="objectName" placeholder="Name (nur für nicht-Stand-Objekte)" class="mt-1 block w-full p-2 border border-gray-300 rounded-md bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200">
                            </div>

                            <div id="standProperties" class="mb-3 hidden">
                                <label for="standWidth" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Breite (m):</label>
                                <input type="number" id="standWidth" step="0.1" class="mt-1 block w-full p-2 border border-gray-300 rounded-md bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200">
                                <label for="standHeight" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Länge (m):</label>
                                <input type="number" id="standHeight" step="0.1" class="mt-1 block w-full p-2 border border-gray-300 rounded-md bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200">
                                <label for="standColor" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mt-2">Farbe:</label>
                                <input type="color" id="standColor" class="mt-1 block w-full h-10 border border-gray-300 rounded-md cursor-pointer">
                            </div>

                            <div id="trashCanProperties" class="mb-3 hidden">
                                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Deckelfarbe:</label>
                                <div class="color-picker-container">
                                    <div class="color-dot yellow-lid" data-color="yellow"></div>
                                    <div class="color-dot blue-lid" data-color="blue"></div>
                                    <div class="color-dot black-lid" data-color="black"></div>
                                </div>
                            </div>

                            <div id="powerOutletProperties" class="mb-3 hidden">
                                <label for="powerOutletLabel" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Vermerk (Zahl):</label>
                                <input type="text" id="powerOutletLabel" class="mt-1 block w-full p-2 border border-gray-300 rounded-md bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200">
                            </div>

                            <div class="flex gap-2 mt-4">
                                <button id="saveObjectButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">
                                    Speichern
                                </button>
                                <button id="deleteObjectButton" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">
                                    Löschen
                                </button>
                            </div>
                        </div>
                    </div>

                    {# Legend #}
                    <div id="legendPanel" class="p-4 content-card rounded-lg shadow-sm">
                        <div class="collapsible-header" data-target="legendContent">
                            <h2 class="text-xl font-semibold text-gray-800 dark:text-gray-200">Legende</h2>
                            <i class="fi fi-rr-angle-down text-xl text-gray-800 dark:text-gray-200"></i>
                        </div>
                        <div id="legendContent" class="collapsible-content">
                            <p class="text-sm">Keine Stände platziert oder Legende aktualisiert.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('floorPlanCanvas');
        const ctx = canvas.getContext('2d');
        const floorPlanUpload = document.getElementById('floorPlanUpload');
        const uploadPlanButton = document.getElementById('uploadPlanButton');
        const currentPlanInfo = document.getElementById('currentPlanInfo');
        const scalePoint1Display = document.getElementById('scalePoint1Display');
        const scalePoint2Display = document.getElementById('scalePoint2Display');
        const scaleDistanceInput = document.getElementById('scaleDistanceInput');
        const setScaleButton = document.getElementById('setScaleButton');
        const pixelsPerMeterDisplay = document.getElementById('pixelsPerMeterDisplay');
        const objectPropertiesPanel = document.getElementById('objectPropertiesPanel');
        const objectIdInput = document.getElementById('objectId');
        const objectTypeInput = document.getElementById('objectType');
        const objectNameInput = document.getElementById('objectName');
        const objectStandIdSelect = document.getElementById('objectStandId');
        const standProperties = document.getElementById('standProperties');
        const standWidthInput = document.getElementById('standWidth');
        const standHeightInput = document.getElementById('standHeight');
        const standColorInput = document.getElementById('standColor');
        const trashCanProperties = document.getElementById('trashCanProperties');
        const powerOutletProperties = document.getElementById('powerOutletProperties');
        const powerOutletLabelInput = document.getElementById('powerOutletLabel');
        const saveObjectButton = document.getElementById('saveObjectButton');
        const deleteObjectButton = document.getElementById('deleteObjectButton');
        const legendContent = document.getElementById('legendContent');
        const zoomInButton = document.getElementById('zoomInButton');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const toggleScaleModeButton = document.getElementById('toggleScaleModeButton');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const backButton = document.getElementById('backButton');
        const mainContainer = document.querySelector('.main-container');


        let floorPlanImage = new Image();
        let currentPlan = null;
        let objects = []; // Array to store all placed objects
        let availableStands = []; // Fetched from backend for stand assignment
        let scalePoints = []; // Stores up to two points for scale definition
        let selectedObject = null;
        let isDraggingCanvas = false;
        let isResizing = false;
        let dragStartX, dragStartY; // For canvas panning
        let offsetX = 0, offsetY = 0; // Current pan offset (in canvas pixels)
        let scale = 1.0; // Current zoom level
        const ZOOM_FACTOR = 1.1;
        let scaleMode = false; // New state variable for scale mode

        // Ensure these match the Tailwind colors for trash cans
        const TRASH_CAN_COLORS = {
            'yellow': '#facc15',
            'blue': '#3b82f6',
            'black': '#1f2937'
        };

        // --- Utility Functions ---

        function displayInlineMessage(message, type = 'info', duration = 5000) {
            const messageBox = document.getElementById('inline-message-container');
            let messageText = messageBox.querySelector('p');
            if (!messageText) {
                messageText = document.createElement('p');
                messageBox.appendChild(messageText);
            }
            messageBox.classList.remove('success', 'error', 'info');
            messageText.textContent = message;
            messageBox.classList.add('show', type);
            setTimeout(() => {
                messageBox.classList.remove('show');
                setTimeout(() => { messageText.textContent = ''; }, 300);
            }, duration);
        }

        async function applyAppSettings() {
            try {
                const response = await fetch('/api/admin_settings');
                const result = await response.json();
                if (result.success) {
                    const settings = result.settings;
                    const body = document.body;
                    const mainLogo = document.getElementById('mainLogo');
                    const faviconLink = document.getElementById('faviconLink');
                    const isDarkModeCurrent = body.classList.contains('dark');

                    // Apply background gradient based on current mode
                    if (isDarkModeCurrent && settings.dark_bg_gradient_color1 && settings.dark_bg_gradient_color2) {
                        body.style.background = `linear-gradient(to bottom right, ${settings.dark_bg_gradient_color1}, ${settings.dark_bg_gradient_color2})`;
                    } else if (settings.bg_gradient_color1 && settings.bg_gradient_color2) {
                        body.style.background = `linear-gradient(to bottom right, ${settings.bg_gradient_color1}, ${settings.bg_gradient_color2})`;
                    } else {
                        // Fallback to default if settings are missing
                        body.style.background = `linear-gradient(to bottom right, #ffb3c1, #a7d9f7)`;
                    }

                    if (settings.logo_url) {
                        mainLogo.src = settings.logo_url;
                        faviconLink.href = settings.logo_url;
                    } else {
                        mainLogo.src = '{{ url_for("general.static_files", filename="img/logo_V2.png") }}';
                        faviconLink.href = '{{ url_for("general.static_files", filename="img/logo_V2.png") }}';
                    }
                } else {
                    console.error('Fehler beim Laden der App-Einstellungen:', result.message);
                }
            } catch (error) {
                console.error('Fehler beim Abrufen der App-Einstellungen:', error);
            }
        }

        function updateButtonAppearance() {
            darkModeToggle.innerHTML = '<i class="fi fi-rr-eclipse-alt"></i>'; // Moon icon
            backButton.innerHTML = '<i class="fi fi-rr-angle-left"></i>'; // Arrow left icon
        }

        // --- Canvas Drawing & Object Management ---

        function draw() {
            // Check if floorPlanImage has a valid source
            if (!floorPlanImage.src || !floorPlanImage.complete || floorPlanImage.naturalWidth === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas if no image
                // No need to set default canvas.width/height here if adjustCanvasSize handles it
                return;
            }

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Save the current canvas state
            ctx.save();

            // Apply pan and zoom
            // Translate first, then scale
            ctx.translate(offsetX, offsetY); 
            ctx.scale(scale, scale);         

            // Draw the background image at (0,0) of the *transformed* coordinate system.
            // Its dimensions will be scaled by the ctx.scale.
            ctx.drawImage(floorPlanImage, 0, 0); 

            // Draw objects
            objects.forEach(obj => {
                ctx.beginPath();
                ctx.lineWidth = 2 / scale; // Keep line width consistent regardless of zoom

                switch (obj.type) {
                    case 'stand':
                        ctx.fillStyle = obj.color || '#cccccc'; // Default grey
                        ctx.strokeStyle = '#000000';
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                        ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                        // Draw stand name if available
                        if (obj.stand_name) {
                            ctx.font = `${14 / scale}px Arial`;
                            // Determine text color based on background for readability
                            const r = parseInt(obj.color.substring(1, 3), 16);
                            const g = parseInt(obj.color.substring(3, 5), 16);
                            const b = parseInt(obj.color.substring(5, 7), 16);
                            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                            if (brightness < 128) {
                                ctx.fillStyle = '#FFFFFF'; // White text for dark colors
                            } else {
                                ctx.fillStyle = '#000000'; // Black text for light colors
                            }

                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(obj.stand_name, obj.x + obj.width / 2, obj.y + obj.height / 2);
                        }
                        break;
                    case 'trash_can':
                        ctx.fillStyle = TRASH_CAN_COLORS[obj.trash_can_color] || '#aaaaaa';
                        ctx.strokeStyle = '#000000';
                        const radius = 15; // Fixed size for trash cans
                        ctx.arc(obj.x + radius, obj.y + radius, radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#000000'; // Black for text
                        ctx.font = `${10 / scale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('M', obj.x + radius, obj.y + radius); // 'M' for Mülleimer
                        // Store fixed width/height for trash can for consistent interaction
                        obj.width = radius * 2;
                        obj.height = radius * 2;
                        break;
                    case 'power_outlet':
                        ctx.fillStyle = '#ffc107'; // Amber color for power outlets
                        ctx.strokeStyle = '#000000';
                        const outletRadius = 15; // Fixed size for power outlets
                        ctx.arc(obj.x + outletRadius, obj.y + outletRadius, outletRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#000000'; // Black for text
                        ctx.font = `${14 / scale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(obj.power_outlet_label || '⚡', obj.x + outletRadius, obj.y + outletRadius); // Default lightning emoji
                        // Store fixed width/height for power outlet for consistent interaction
                        obj.width = outletRadius * 2;
                        obj.height = outletRadius * 2;
                        break;
                }

                // Draw selection rectangle if object is selected
                if (selectedObject && selectedObject.id === obj.id) {
                    ctx.strokeStyle = '#3b82f6'; // blue-500
                    ctx.lineWidth = 4 / scale;
                    if (obj.type === 'stand') {
                        ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                        // Draw resize handle (bottom-right corner)
                        ctx.fillStyle = '#3b82f6';
                        const handleSize = 10 / scale;
                        ctx.fillRect(obj.x + obj.width - handleSize, obj.y + obj.height - handleSize, handleSize, handleSize);
                    } else { // For trash can and power outlet, just a thicker border as they are fixed size
                        ctx.stroke(); // Close the path for the circle
                    }
                }
            });

            // Draw scale points
            scalePoints.forEach((p, index) => {
                ctx.fillStyle = index === 0 ? 'red' : 'green';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5 / scale, 0, Math.PI * 2); // Radius also scaled
                ctx.fill();
            });

            // Restore canvas state
            ctx.restore();
        }

        // Adjust canvas size to match image dimensions or default
        function adjustCanvasSize() {
            const container = canvas.parentElement; // The div that wraps the canvas
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // Set canvas drawing buffer size to match its container's actual size
            canvas.width = containerWidth;
            canvas.height = containerHeight;

            if (floorPlanImage.src && floorPlanImage.complete && floorPlanImage.naturalWidth > 0) {
                // Calculate scale to fit the image within the new canvas dimensions
                const scaleX = canvas.width / floorPlanImage.width;
                const scaleY = canvas.height / floorPlanImage.height;
                scale = Math.min(scaleX, scaleY); // Fit the image, potentially zooming out if needed

                // Ensure it doesn't zoom in too much initially if image is small
                scale = Math.min(scale, 1.0); 

                // Calculate offset to center the scaled image within the canvas
                offsetX = (canvas.width - floorPlanImage.width * scale) / 2;
                offsetY = (canvas.height - floorPlanImage.height * scale) / 2;
            } else {
                // No image, reset scale and offset to defaults for an empty canvas
                scale = 1.0;
                offsetX = 0;
                offsetY = 0;
            }
            draw();
        }

        // IMPORTANT: Corrected getMousePos function
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);
            return {
                x: (clientX - rect.left - offsetX) / scale,
                y: (clientY - rect.top - offsetY) / scale
            };
        }


        function getObjectAtPoint(x, y) {
            for (let i = objects.length - 1; i >= 0; i--) { // Iterate backwards to pick top-most object
                const obj = objects[i];
                
                // For circular objects (trash_can, power_outlet), check distance from center
                if (obj.type === 'trash_can' || obj.type === 'power_outlet') {
                    const radius = 15; // Match drawing radius
                    const centerX = obj.x + radius;
                    const centerY = obj.y + radius;
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    if (distance <= radius) {
                        return obj;
                    }
                } else { // For rectangular objects (stand)
                    if (x >= obj.x && x <= obj.x + obj.width &&
                        y >= obj.y && y <= obj.y + obj.height) {
                        return obj;
                    }
                }
            }
            return null;
        }

        function showObjectProperties(obj) {
            selectedObject = obj;
            objectPropertiesPanel.classList.remove('hidden');
            objectIdInput.value = obj.id || '';
            objectTypeInput.value = obj.type;

            // Reset visibility of specific property sections
            standProperties.classList.add('hidden');
            trashCanProperties.classList.add('hidden');
            powerOutletProperties.classList.add('hidden');
            objectNameInput.classList.add('hidden'); // Hide for stands initially
            objectStandIdSelect.classList.add('hidden'); // Hide for non-stands initially

            // Populate common fields
            objectNameInput.value = obj.name || ''; // Name is only for non-stand objects

            // Populate specific fields based on type
            if (obj.type === 'stand') {
                standProperties.classList.remove('hidden');
                objectStandIdSelect.classList.remove('hidden');
                objectNameInput.classList.add('hidden'); // Stands use stand_id for naming

                // Convert pixel dimensions to meters for display if pixels_per_meter is defined
                standWidthInput.value = currentPlan && currentPlan.pixels_per_meter ? (obj.width / currentPlan.pixels_per_meter).toFixed(1) : (obj.width / 1).toFixed(1);
                standHeightInput.value = currentPlan && currentPlan.pixels_per_meter ? (obj.height / currentPlan.pixels_per_meter).toFixed(1) : (obj.height / 1).toFixed(1);
                
                standColorInput.value = obj.color || '#cccccc';

                // Set selected stand in dropdown
                if (obj.stand_id) {
                    objectStandIdSelect.value = obj.stand_id;
                } else {
                    objectStandIdSelect.value = '';
                }

                // Add event listener for stand dropdown change
                objectStandIdSelect.onchange = (e) => {
                    const selectedStandId = e.target.value;
                    const selectedStand = availableStands.find(s => s.id == selectedStandId);
                    if (selectedStand) {
                        // Update object name for display on canvas and in object properties
                        selectedObject.name = selectedStand.name; // Keep name property updated
                        selectedObject.stand_name = selectedStand.name; // Update object in memory for drawing
                        selectedObject.stand_id = parseInt(selectedStandId);
                    } else {
                        selectedObject.name = '';
                        selectedObject.stand_name = '';
                        selectedObject.stand_id = null;
                    }
                    draw();
                };

            } else if (obj.type === 'trash_can') {
                trashCanProperties.classList.remove('hidden');
                objectNameInput.classList.remove('hidden'); // Trash cans can have a custom name
                objectStandIdSelect.classList.add('hidden');
                objectNameInput.placeholder = 'Name (optional)'; // Adjust placeholder

                // Set selected trash can color dot
                document.querySelectorAll('#trashCanProperties .color-dot').forEach(dot => {
                    dot.classList.remove('selected');
                    if (dot.dataset.color === obj.trash_can_color) {
                        dot.classList.add('selected');
                    }
                });

            } else if (obj.type === 'power_outlet') {
                powerOutletProperties.classList.remove('hidden');
                objectNameInput.classList.remove('hidden'); // Power outlets can have a custom name
                objectStandIdSelect.classList.add('hidden');
                objectNameInput.placeholder = 'Name (optional)'; // Adjust placeholder

                powerOutletLabelInput.value = obj.power_outlet_label || '';
            }

            draw(); // Redraw to show selection
        }

        function hideObjectProperties() {
            selectedObject = null;
            objectPropertiesPanel.classList.add('hidden');
            draw(); // Redraw to remove selection
        }

        function updateLegend() {
            legendContent.innerHTML = ''; // Clear existing legend

            const standColors = {}; // { color: [stand_name1, stand_name2], ... }

            objects.filter(obj => obj.type === 'stand' && obj.stand_name && obj.color)
                   .forEach(stand => {
                        if (!standColors[stand.color]) {
                            standColors[stand.color] = [];
                        }
                        // Only add if not already present to avoid duplicates
                        if (!standColors[stand.color].includes(stand.stand_name)) {
                            standColors[stand.color].push(stand.stand_name);
                        }
                   });

            if (Object.keys(standColors).length === 0) {
                legendContent.innerHTML = '<p class="text-sm text-gray-600 dark:text-gray-300">Keine Stände mit Farbe platziert.</p>';
                return;
            }

            for (const color in standColors) {
                const names = standColors[color].sort().join(', '); // Sort names for consistent legend
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color-box" style="background-color: ${color};"></div>
                    <span>${names}</span>
                `;
                legendContent.appendChild(legendItem);
            }
        }

        // --- API Interactions ---

        async function fetchActivePlan() {
            try {
                const response = await fetch('/api/get_active_plan');
                const data = await response.json();
                if (data.success && data.plan) {
                    currentPlan = data.plan;
                    objects = data.objects;
                    availableStands = data.available_stands;

                    // Populate stand dropdown
                    objectStandIdSelect.innerHTML = '<option value="">Wählen Sie einen Stand...</option>';
                    availableStands.forEach(stand => {
                        const option = document.createElement('option');
                        option.value = stand.id;
                        option.textContent = stand.name;
                        objectStandIdSelect.appendChild(option);
                    });

                    floorPlanImage.src = currentPlan.image_url;
                    floorPlanImage.onload = () => {
                        // Ensure currentPlan has width_px and height_px from the loaded image
                        // This is crucial for scale calculations and object placement limits
                        currentPlan.width_px = floorPlanImage.naturalWidth;
                        currentPlan.height_px = floorPlanImage.naturalHeight;
                        
                        // If scale data exists in the fetched plan, apply it
                        if (currentPlan.scale_point1_x && currentPlan.scale_point2_x && currentPlan.scale_distance_meters) {
                            scalePoints = [{ x: currentPlan.scale_point1_x, y: currentPlan.scale_point1_y },
                                           { x: currentPlan.scale_point2_x, y: currentPlan.scale_point2_y }];
                            scaleDistanceInput.value = currentPlan.scale_distance_meters; // Set input field
                            calculatePixelsPerMeter(); // Calculate and display from fetched data
                        } else {
                             scalePoints = []; // Reset if no scale data
                             scalePoint1Display.textContent = '-';
                             scalePoint2Display.textContent = '-';
                             pixelsPerMeterDisplay.textContent = 'Maßstab: Nicht definiert';
                             setScaleButton.disabled = true;
                        }

                        adjustCanvasSize(); // This will also redraw and handle initial pan/zoom
                        draw();
                        updateLegend();
                        currentPlanInfo.textContent = `Aktueller Plan: ${currentPlan.name}`;
                    };
                    floorPlanImage.onerror = () => {
                        displayInlineMessage('Fehler beim Laden des Lageplanbildes. Bitte überprüfen Sie den Pfad oder laden Sie es erneut hoch.', 'error');
                        currentPlanInfo.textContent = 'Fehler beim Laden des Plans.';
                        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
                        floorPlanImage.src = ''; // Clear broken image
                        scalePoints = []; // Reset points
                        updateLegend();
                    };

                } else if (!data.plan) {
                    currentPlanInfo.textContent = 'Kein aktiver Plan vorhanden. Bitte laden Sie einen hoch.';
                    displayInlineMessage('Kein aktiver Lageplan gefunden. Bitte laden Sie einen hoch.', 'info');
                    // Reset canvas if no active plan
                    floorPlanImage.src = '';
                    objects = [];
                    adjustCanvasSize();
                    updateLegend();
                } else {
                    displayInlineMessage(data.message, 'error');
                }
            } catch (error) {
                console.error('Fehler beim Abrufen des aktiven Lageplans:', error);
                displayInlineMessage('Fehler beim Laden des Lageplans.', 'error');
            }
        }


        async function saveObject(obj) {
            try {
                const response = await fetch('/api/save_floor_plan_object', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: obj.id,
                        plan_id: currentPlan.id,
                        type: obj.type,
                        x: obj.x,
                        y: obj.y,
                        width: obj.width,
                        height: obj.height,
                        color: obj.color,
                        trash_can_color: obj.trash_can_color,
                        power_outlet_label: obj.power_outlet_label,
                        stand_id: obj.stand_id || null // Ensure null if not assigned
                    })
                });
                const data = await response.json();
                if (data.success) {
                    displayInlineMessage(data.message, 'success');
                    if (!obj.id) { // If new object, update its ID
                        obj.id = data.object_id;
                    }
                    draw();
                    updateLegend();
                    // Re-fetch to get updated stand_name for newly associated stands
                    // This is heavy, consider just updating `obj.stand_name` if `obj.stand_id` is set
                    // For now, let's keep fetchActivePlan() to ensure consistency
                    fetchActivePlan(); 
                } else {
                    displayInlineMessage(data.message, 'error');
                }
            } catch (error) {
                console.error('Fehler beim Speichern des Objekts:', error);
                displayInlineMessage('Fehler beim Speichern des Objekts.', 'error');
            }
        }

        async function deleteObject(objId) {
            // Use custom confirmation instead of browser's alert/confirm
            const confirmDelete = await showCustomConfirm('Sind Sie sicher, dass Sie dieses Objekt löschen möchten?', 'Löschen bestätigen');
            if (!confirmDelete) return;

            try {
                const response = await fetch(`/api/delete_floor_plan_object/${objId}`, {
                    method: 'DELETE'
                });
                const data = await response.json();
                if (data.success) {
                    displayInlineMessage(data.message, 'success');
                    objects = objects.filter(obj => obj.id !== objId);
                    hideObjectProperties();
                    draw();
                    updateLegend();
                } else {
                    displayInlineMessage(data.message, 'error');
                }
            } catch (error) {
                console.error('Fehler beim Löschen des Objekts:', error);
                displayInlineMessage('Fehler beim Löschen des Objekts.', 'error');
            }
        }

        async function updatePlanScaleInDB() {
            if (!currentPlan) {
                displayInlineMessage('Kein aktiver Plan zum Speichern der Skalierung vorhanden.', 'error');
                return;
            }
            if (scalePoints.length < 2) {
                displayInlineMessage('Bitte setzen Sie beide Skalierungspunkte.', 'info');
                return;
            }

            const distanceMeters = parseFloat(scaleDistanceInput.value);
            if (isNaN(distanceMeters) || distanceMeters <= 0) {
                displayInlineMessage('Bitte geben Sie eine gültige positive Distanz ein.', 'error');
                return;
            }

            try {
                const response = await fetch('/api/update_plan_scale', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        plan_id: currentPlan.id,
                        scale_point1_x: scalePoints[0].x,
                        scale_point1_y: scalePoints[0].y,
                        scale_point2_x: scalePoints[1].x,
                        scale_point2_y: scalePoints[1].y,
                        scale_distance_meters: distanceMeters,
                        width_px: floorPlanImage.naturalWidth, // Save original image dimensions
                        height_px: floorPlanImage.naturalHeight // Save original image dimensions
                    })
                });
                const data = await response.json();
                if (data.success) {
                    // Update currentPlan object with new scale data
                    currentPlan.scale_point1_x = scalePoints[0].x;
                    currentPlan.scale_point1_y = scalePoints[0].y;
                    currentPlan.scale_point2_x = scalePoints[1].x;
                    currentPlan.scale_point2_y = scalePoints[1].y;
                    currentPlan.scale_distance_meters = distanceMeters;
                    currentPlan.width_px = floorPlanImage.naturalWidth; 
                    currentPlan.height_px = floorPlanImage.naturalHeight;

                    calculatePixelsPerMeter(); // Re-calculate to update the display based on newly saved data
                    displayInlineMessage(data.message, 'success');
                    toggleScaleMode(false); // Exit scale mode after saving
                } else {
                    displayInlineMessage(data.message, 'error');
                }
            } catch (error) {
                console.error('Fehler beim Aktualisieren der Skalierung:', error);
                displayInlineMessage('Fehler beim Speichern der Skalierung.', 'error');
            }
        }

        // --- Scale Calculation ---

        function calculatePixelsPerMeter() {
            const distanceMeters = parseFloat(scaleDistanceInput.value);

            if (scalePoints.length === 2 && !isNaN(distanceMeters) && distanceMeters > 0) {
                const px1 = scalePoints[0];
                const px2 = scalePoints[1];
                const pixelDistance = Math.sqrt(Math.pow(px2.x - px1.x, 2) + Math.pow(px2.y - px1.y, 2));
                const calculatedPixelsPerMeter = pixelDistance / distanceMeters;
                
                pixelsPerMeterDisplay.textContent = `Maßstab: ${calculatedPixelsPerMeter.toFixed(2)} Pixel/Meter`;
                setScaleButton.disabled = false;
                
                // Store calculated pixels_per_meter in currentPlan for immediate use
                if (currentPlan) {
                    currentPlan.pixels_per_meter = calculatedPixelsPerMeter;
                }
            } else {
                pixelsPerMeterDisplay.textContent = 'Maßstab: Nicht definiert';
                setScaleButton.disabled = true;
                if (currentPlan) {
                    currentPlan.pixels_per_meter = null; // Clear if not calculable
                }
            }
        }

        // --- Custom Confirmation Dialog ---
        function showCustomConfirm(message, title = 'Bestätigen') {
            return new Promise((resolve) => {
                const modalHtml = `
                    <div id="customConfirmModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center z-[1001]">
                        <div class="relative p-5 border w-96 shadow-lg rounded-md bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100">
                            <h3 class="text-lg font-bold mb-4">${title}</h3>
                            <p class="mb-6">${message}</p>
                            <div class="flex justify-end space-x-4">
                                <button id="confirmNo" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-400 dark:hover:bg-gray-600 focus:outline-none">
                                    Nein
                                </button>
                                <button id="confirmYes" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none">
                                    Ja
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHtml);

                const modal = document.getElementById('customConfirmModal');
                document.getElementById('confirmYes').onclick = () => {
                    modal.remove();
                    resolve(true);
                };
                document.getElementById('confirmNo').onclick = () => {
                    modal.remove();
                    resolve(false);
                };
            });
        }


        // --- Event Listeners ---

        // File Upload
        uploadPlanButton.addEventListener('click', async () => {
            const file = floorPlanUpload.files[0];
            if (!file) {
                displayInlineMessage('Bitte wählen Sie eine Datei aus.', 'info');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload_floor_plan', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                if (data.success) {
                    displayInlineMessage(data.message, 'success');
                    currentPlan = data.plan;
                    floorPlanImage.src = data.plan.image_url; // Use the URL provided by the backend
                    floorPlanImage.onload = () => {
                        // Always save natural dimensions after loading a new image
                        currentPlan.width_px = floorPlanImage.naturalWidth;
                        currentPlan.height_px = floorPlanImage.naturalHeight;
                        // No need to call updatePlanScaleInDB here just for dimensions,
                        // it will be called when the scale is actually set/saved.
                        
                        adjustCanvasSize(); // This will also redraw
                        objects = []; // Clear existing objects for a new plan
                        updateLegend();
                        currentPlanInfo.textContent = `Aktueller Plan: ${currentPlan.name}`;
                        scalePoints = []; // Reset scale points for new plan
                        scalePoint1Display.textContent = '-';
                        scalePoint2Display.textContent = '-';
                        scaleDistanceInput.value = '';
                        calculatePixelsPerMeter(); // Reset display
                        toggleScaleMode(false); // Ensure scale mode is off after upload
                    };
                     floorPlanImage.onerror = () => {
                        displayInlineMessage('Fehler beim Laden des Lageplanbildes. Bitte überprüfen Sie den Pfad oder laden Sie es erneut hoch.', 'error');
                        currentPlanInfo.textContent = 'Fehler beim Laden des Plans.';
                        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
                        floorPlanImage.src = ''; // Clear broken image
                        scalePoints = []; // Reset points
                        updateLegend();
                    };
                } else {
                    displayInlineMessage(data.message, 'error');
                }
            } catch (error) {
                console.error('Fehler beim Hochladen des Plans:', error);
                displayInlineMessage('Fehler beim Hochladen des Plans.', 'error');
            }
        });

        // Toggle Scale Mode
        toggleScaleModeButton.addEventListener('click', () => {
            toggleScaleMode();
        });

        function toggleScaleMode(forceState = undefined) {
            if (forceState !== undefined) {
                scaleMode = forceState;
            } else {
                scaleMode = !scaleMode;
            }

            if (scaleMode) {
                toggleScaleModeButton.textContent = 'Maßstab Modus deaktivieren';
                toggleScaleModeButton.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                toggleScaleModeButton.classList.add('bg-red-600', 'hover:bg-red-700');
                canvas.classList.add('scale-mode');
                displayInlineMessage('Maßstab-Modus aktiviert. Klicken Sie auf den Plan, um Punkte zu setzen.', 'info');
            } else {
                toggleScaleModeButton.textContent = 'Maßstab Modus aktivieren';
                toggleScaleModeButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleScaleModeButton.classList.add('bg-purple-600', 'hover:bg-purple-700');
                canvas.classList.remove('scale-mode');
                displayInlineMessage('Maßstab-Modus deaktiviert.', 'info');
            }
            // Clear current scale points when toggling off
            if (!scaleMode) {
                scalePoints = [];
                scalePoint1Display.textContent = '-';
                scalePoint2Display.textContent = '-';
                scaleDistanceInput.value = ''; // Also clear the input field
                calculatePixelsPerMeter(); // Update button state and display
            }
            draw(); // Redraw canvas to clear scale points if mode is off
        }


        // Scale definition
        canvas.addEventListener('click', (e) => {
            if (scaleMode) {
                if (!currentPlan || !floorPlanImage.src) {
                    displayInlineMessage('Bitte laden Sie zuerst einen Lageplan hoch.', 'info');
                    return;
                }
                const mousePos = getMousePos(e);
                if (scalePoints.length < 2) {
                    scalePoints.push(mousePos);
                    if (scalePoints.length === 1) {
                        scalePoint1Display.textContent = `(${mousePos.x.toFixed(0)}, ${mousePos.y.toFixed(0)})`;
                    } else if (scalePoints.length === 2) {
                        scalePoint2Display.textContent = `(${mousePos.x.toFixed(0)}, ${mousePos.y.toFixed(0)})`;
                    }
                } else {
                    scalePoints = [mousePos]; // Reset to first point
                    scalePoint1Display.textContent = `(${mousePos.x.toFixed(0)}, ${mousePos.y.toFixed(0)})`;
                    scalePoint2Display.textContent = '-';
                }
                calculatePixelsPerMeter(); // Recalculate and update button state
                draw();
            }
        });

        scaleDistanceInput.addEventListener('input', calculatePixelsPerMeter);
        setScaleButton.addEventListener('click', updatePlanScaleInDB);

        // Toolbox Drag and Drop
        document.querySelectorAll('.toolbox-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.dataset.objectType);
                e.dataTransfer.effectAllowed = 'copy';
                hideObjectProperties(); // Hide properties when starting drag
            });
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            e.dataTransfer.dropEffect = 'copy';
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!currentPlan) {
                displayInlineMessage('Bitte laden Sie zuerst einen Lageplan hoch.', 'info');
                return;
            }
            if (scaleMode) { // Prevent dropping objects in scale mode
                displayInlineMessage('Bitte deaktivieren Sie den Maßstab-Modus, um Objekte zu platzieren.', 'info');
                return;
            }


            const objectType = e.dataTransfer.getData('text/plain');
            const mousePos = getMousePos(e);

            let newObject = {
                plan_id: currentPlan.id,
                type: objectType,
                x: mousePos.x,
                y: mousePos.y,
                width: 0, // Will be set based on type or input
                height: 0, // Will be set based on type or input
                color: '#cccccc', // Default color for stand
                trash_can_color: 'yellow', // Default for trash can
                power_outlet_label: '1', // Default for power outlet
                stand_id: null,
                name: '', // Use 'name' for non-stand objects
                stand_name: '' // For stands, synced with `stands` table
            };

            if (objectType === 'stand') {
                newObject.width = 50; // Default pixel size
                newObject.height = 50; // Default pixel size
            } else if (objectType === 'trash_can') {
                newObject.width = 30; // Fixed pixel size
                newObject.height = 30; // Fixed pixel size
                newObject.x -= 15; // Center the circle
                newObject.y -= 15; // Center the circle
            } else if (objectType === 'power_outlet') {
                newObject.width = 30; // Fixed pixel size
                newObject.height = 30; // Fixed pixel size
                newObject.x -= 15; // Center the circle
                newObject.y -= 15; // Center the circle
            }

            objects.push(newObject);
            draw();
            saveObject(newObject); // Save the new object to DB
            showObjectProperties(newObject); // Immediately show properties for new object
        });

        // Object interaction (click, drag, resize)
        let dragOffsetX, dragOffsetY;

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (scaleMode) return; // Prevent interaction in scale mode

            const mousePos = getMousePos(e);

            // Check for resize handle (only for stands)
            if (selectedObject && selectedObject.type === 'stand') {
                const handleSize = 10 / scale;
                // Convert handle position to scaled canvas coordinates for hit test
                const handleX = selectedObject.x + selectedObject.width - handleSize;
                const handleY = selectedObject.y + selectedObject.height - handleSize;

                if (mousePos.x >= handleX && mousePos.x <= handleX + handleSize &&
                    mousePos.y >= handleY && mousePos.y <= handleY + handleSize) {
                    isResizing = true;
                    // Store initial mouse pos relative to handle for resizing
                    dragOffsetX = mousePos.x - selectedObject.width;
                    dragOffsetY = mousePos.y - selectedObject.height;
                    canvas.style.cursor = 'nwse-resize';
                    return;
                }
            }

            const clickedObject = getObjectAtPoint(mousePos.x, mousePos.y);

            if (clickedObject) {
                selectedObject = clickedObject;
                dragOffsetX = mousePos.x - selectedObject.x;
                dragOffsetY = mousePos.y - selectedObject.y;
                canvas.style.cursor = 'grabbing';
                showObjectProperties(selectedObject);
            } else {
                // If no object clicked, start panning the canvas
                isDraggingCanvas = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                canvas.style.cursor = 'grabbing';
                hideObjectProperties(); // Hide properties if nothing selected
            }
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (scaleMode && e.buttons === 0 && e.touches === undefined) { // In scale mode, only allow cursor change, no drag
                canvas.style.cursor = 'crosshair';
                return;
            }
            if (scaleMode) return; // No other interaction in scale mode

            const mousePos = getMousePos(e); // Get mouse position in unscaled canvas coordinates

            if (isResizing && selectedObject && selectedObject.type === 'stand') {
                // Calculate new width and height based on mouse movement
                let newWidth = mousePos.x - selectedObject.x;
                let newHeight = mousePos.y - selectedObject.y;

                // Ensure minimum size
                newWidth = Math.max(newWidth, 10);
                newHeight = Math.max(newHeight, 10);

                // Ensure within image bounds
                newWidth = Math.min(newWidth, floorPlanImage.naturalWidth - selectedObject.x);
                newHeight = Math.min(newHeight, floorPlanImage.naturalHeight - selectedObject.y);

                selectedObject.width = newWidth;
                selectedObject.height = newHeight;
                // Update input fields with calculated values in meters
                if (currentPlan && currentPlan.pixels_per_meter) {
                    standWidthInput.value = (selectedObject.width / currentPlan.pixels_per_meter).toFixed(1);
                    standHeightInput.value = (selectedObject.height / currentPlan.pixels_per_meter).toFixed(1);
                } else {
                    standWidthInput.value = (selectedObject.width).toFixed(1);
                    standHeightInput.value = (selectedObject.height).toFixed(1);
                }
                draw();

            } else if (selectedObject && !isDraggingCanvas && (e.buttons === 1 || e.type === 'touchmove')) {
                // Dragging selected object
                let newX = mousePos.x - dragOffsetX;
                let newY = mousePos.y - dragOffsetY;

                // Keep objects within image boundaries
                newX = Math.max(0, Math.min(newX, floorPlanImage.naturalWidth - selectedObject.width));
                newY = Math.max(0, Math.min(newY, floorPlanImage.naturalHeight - selectedObject.height));

                selectedObject.x = newX;
                selectedObject.y = newY;
                draw();
            } else if (isDraggingCanvas) {
                // Pan the canvas
                const dx = (e.clientX || e.touches[0].clientX) - dragStartX;
                const dy = (e.clientY || e.touches[0].clientY) - dragStartY;
                offsetX += dx;
                offsetY += dy;
                dragStartX = (e.clientX || e.touches[0].clientX);
                dragStartY = (e.clientY || e.touches[0].clientY);
                draw();
            } else {
                // Cursor feedback when hovering
                const hoveredObject = getObjectAtPoint(mousePos.x, mousePos.y);
                if (selectedObject && selectedObject.type === 'stand') {
                    const handleSize = 10 / scale;
                    const handleX = selectedObject.x + selectedObject.width - handleSize;
                    const handleY = selectedObject.y + selectedObject.height - handleSize;
                    if (mousePos.x >= handleX && mousePos.x <= handleX + handleSize &&
                        mousePos.y >= handleY && mousePos.y <= handleY + handleSize) {
                        canvas.style.cursor = 'nwse-resize';
                        return; // Prevent other cursor changes
                    }
                }
                if (hoveredObject) {
                    canvas.style.cursor = 'grab';
                } else if (!isDraggingCanvas) {
                    canvas.style.cursor = 'grab'; // Default cursor for canvas when not dragging/resizing
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (scaleMode) return; // Prevent interaction in scale mode

            canvas.style.cursor = 'grab'; // Reset cursor
            if (isResizing) {
                isResizing = false;
                if (selectedObject) {
                    saveObject(selectedObject);
                }
            } else if (selectedObject && !isDraggingCanvas) {
                // Save object position if it was dragged or clicked (to ensure properties are updated)
                saveObject(selectedObject);
            } else if (isDraggingCanvas) {
                isDraggingCanvas = false;
            }
        });
        // Touch events for drag/pan
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (scaleMode) return;

            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                buttons: 1 // Simulate left click
            });
            canvas.dispatchEvent(mouseEvent);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (scaleMode) return;

            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                buttons: 1
            });
            canvas.dispatchEvent(mouseEvent);
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (scaleMode) return;

            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        }, { passive: false });


        // Zoom functionality
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (scaleMode) return; // Prevent zooming in scale mode

            const mouseX = (e.clientX - canvas.getBoundingClientRect().left);
            const mouseY = (e.clientY - canvas.getBoundingClientRect().top);

            const oldScale = scale;
            let newScale = e.deltaY < 0 ? scale * ZOOM_FACTOR : scale / ZOOM_FACTOR;

            // Limit zoom to ensure image always fills at least the canvas initially
            const minScaleX = canvas.width / floorPlanImage.naturalWidth;
            const minScaleY = canvas.height / floorPlanImage.naturalHeight;
            let minScale = Math.min(minScaleX, minScaleY); // Always fit the image entirely

            // If the image is smaller than the canvas, ensure we don't zoom out past 1.0 (original size)
            if (floorPlanImage.naturalWidth <= canvas.width && floorPlanImage.naturalHeight <= canvas.height) {
                minScale = Math.min(minScale, 1.0); // Don't zoom out smaller than actual size if image fits
            } else {
                minScale = Math.min(minScale, 1.0); // Keep original logic if image is larger
            }


            const maxScale = 5.0; // Max zoom in, adjust as needed

            if (newScale >= minScale && newScale <= maxScale) {
                scale = newScale;

                // Adjust offsetX and offsetY to zoom towards the mouse position
                offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
                offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);
            }
            draw();
        });

        zoomInButton.addEventListener('click', () => {
            if (scaleMode) return;
            const mouseX = canvas.width / 2; // Zoom towards center of canvas
            const mouseY = canvas.height / 2;

            const oldScale = scale;
            const newScale = scale * ZOOM_FACTOR;
            const maxScale = 5.0;

            if (newScale <= maxScale) {
                scale = newScale;
                offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
                offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);
                draw();
            }
        });

        zoomOutButton.addEventListener('click', () => {
            if (scaleMode) return;
            const mouseX = canvas.width / 2; // Zoom towards center of canvas
            const mouseY = canvas.height / 2;

            const oldScale = scale;
            const newScale = scale / ZOOM_FACTOR;
            
            const minScaleX = canvas.width / floorPlanImage.naturalWidth;
            const minScaleY = canvas.height / floorPlanImage.naturalHeight;
            let minScale = Math.min(minScaleX, minScaleY);

            // If the image is smaller than the canvas, ensure we don't zoom out past 1.0 (original size)
            if (floorPlanImage.naturalWidth <= canvas.width && floorPlanImage.naturalHeight <= canvas.height) {
                minScale = Math.min(minScale, 1.0); // Don't zoom out smaller than actual size if image fits
            } else {
                minScale = Math.min(minScale, 1.0); // Keep original logic if image is larger
            }


            if (newScale >= minScale) {
                scale = newScale;
                offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
                offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);
                draw();
            }
        });


        // Object properties editor events
        saveObjectButton.addEventListener('click', () => {
            if (selectedObject) {
                if (selectedObject.type === 'stand') {
                    // Convert back to pixels for storage
                    selectedObject.width = parseFloat(standWidthInput.value) * (currentPlan.pixels_per_meter || 1);
                    selectedObject.height = parseFloat(standHeightInput.value) * (currentPlan.pixels_per_meter || 1);
                    selectedObject.color = standColorInput.value;
                    selectedObject.stand_id = parseInt(objectStandIdSelect.value) || null;
                    // Update name based on selected stand (or empty if none)
                    selectedObject.stand_name = objectStandIdSelect.options[objectStandIdSelect.selectedIndex].text;
                    if (objectStandIdSelect.value === "") { // If "Wählen Sie einen Stand..." is selected
                        selectedObject.stand_name = '';
                    }

                } else if (selectedObject.type === 'trash_can') {
                    selectedObject.name = objectNameInput.value; // Store name for trash cans
                    const selectedColorDot = document.querySelector('#trashCanProperties .color-dot.selected');
                    selectedObject.trash_can_color = selectedColorDot ? selectedColorDot.dataset.color : 'yellow';
                } else if (selectedObject.type === 'power_outlet') {
                    selectedObject.name = objectNameInput.value; // Store name for power outlets
                    selectedObject.power_outlet_label = powerOutletLabelInput.value;
                }
                saveObject(selectedObject);
            }
        });

        deleteObjectButton.addEventListener('click', () => {
            if (selectedObject && selectedObject.id) {
                deleteObject(selectedObject.id);
            }
        });

        // Trash can color selection
        document.querySelectorAll('#trashCanProperties .color-dot').forEach(dot => {
            dot.addEventListener('click', () => {
                document.querySelectorAll('#trashCanProperties .color-dot').forEach(d => d.classList.remove('selected'));
                dot.classList.add('selected');
                if (selectedObject && selectedObject.type === 'trash_can') {
                    selectedObject.trash_can_color = dot.dataset.color;
                    draw();
                }
            });
        });

        // Collapsible sections functionality
        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                const icon = header.querySelector('i');

                content.classList.toggle('collapsed');
                header.classList.toggle('collapsed'); // Rotate arrow
            });
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', async () => {
            await applyAppSettings(); // Load and apply app settings (for dark mode, logo)
            updateButtonAppearance(); // Set initial dark mode icon and back button icon
            fetchActivePlan(); // Fetch the active plan and its objects

            document.getElementById('backButton').addEventListener('click', () => {
                window.location.href = '{{ url_for("general.home") }}';
            });

            document.getElementById('darkModeToggle').addEventListener('click', async () => {
                try {
                    const response = await fetch('{{ url_for("general.toggle_dark_mode") }}', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await response.json();
                    if (data.dark_mode_enabled) {
                        document.body.classList.add('dark');
                    } else {
                        document.body.classList.remove('dark');
                    }
                    updateButtonAppearance(); // Re-set icon based on new mode
                    await applyAppSettings(); // Re-apply background
                } catch (error) {
                    console.error('Error toggling dark mode:', error);
                    displayInlineMessage('Fehler beim Umschalten des Dark Mode.', 'error');
                }
            });

            // Ensure canvas is resized if window resizes
            window.addEventListener('resize', adjustCanvasSize);

            // Handle image load errors
            floorPlanImage.onerror = () => {
                displayInlineMessage('Fehler beim Laden des Lageplanbildes. Bitte überprüfen Sie den Pfad oder laden Sie es erneut hoch.', 'error');
                currentPlanInfo.textContent = 'Fehler beim Laden des Plans.';
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
                floorPlanImage.src = ''; // Clear broken image
                scalePoints = []; // Reset points
                updateLegend();
            };
        });
    </script>
</body>
</html>
